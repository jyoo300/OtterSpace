{"ast":null,"code":"var _jsxFileName = \"/Users/johnyoo/Desktop/OtterSpace/src/util/auth.js\";\nimport React, { useState, useEffect, useMemo, useContext, createContext } from \"react\";\nimport queryString from \"query-string\";\nimport firebase from \"./firebase\";\nimport { useUser, createUser, updateUser } from \"./db\";\nimport { history } from \"./router\";\nimport PageLoader from \"./../components/PageLoader\"; // Whether to merge user data from database into auth.user\n\nconst MERGE_DB_USER = true;\nconst authContext = createContext(); // Context Provider component that wraps your app and makes auth object\n// available to any child component that calls the useAuth() hook.\n\nexport function ProvideAuth({\n  children\n}) {\n  const auth = useProvideAuth();\n  return /*#__PURE__*/React.createElement(authContext.Provider, {\n    value: auth,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 23,\n      columnNumber: 10\n    }\n  }, children);\n} // Hook that enables any component to subscribe to auth state\n\nexport const useAuth = () => {\n  return useContext(authContext);\n}; // Provider hook that creates auth object and handles state\n\nfunction useProvideAuth() {\n  // Store auth user object\n  const [user, setUser] = useState(null); // Format final user object and merge extra data from database\n\n  const finalUser = usePrepareUser(user); // Handle response from authentication functions\n\n  const handleAuth = async response => {\n    const {\n      user,\n      additionalUserInfo\n    } = response; // Ensure Firebase is actually ready before we continue\n\n    await waitForFirebase(); // Create the user in the database if they are new\n\n    if (additionalUserInfo.isNewUser) {\n      await createUser(user.uid, {\n        email: user.email\n      });\n    } // Update user in state\n\n\n    setUser(user);\n    return user;\n  };\n\n  const signup = (email, password) => {\n    return firebase.auth().createUserWithEmailAndPassword(email, password).then(handleAuth);\n  };\n\n  const signin = (email, password) => {\n    return firebase.auth().signInWithEmailAndPassword(email, password).then(handleAuth);\n  };\n\n  const signinWithProvider = name => {\n    // Get provider data by name (\"password\", \"google\", etc)\n    const providerData = allProviders.find(p => p.name === name);\n    const provider = new providerData.providerMethod();\n\n    if (providerData.parameters) {\n      provider.setCustomParameters(providerData.parameters);\n    }\n\n    return firebase.auth().signInWithPopup(provider).then(handleAuth);\n  };\n\n  const signout = () => {\n    return firebase.auth().signOut();\n  };\n\n  const sendPasswordResetEmail = email => {\n    return firebase.auth().sendPasswordResetEmail(email);\n  };\n\n  const confirmPasswordReset = (password, code) => {\n    // Get code from query string object\n    const resetCode = code || getFromQueryString(\"oobCode\");\n    return firebase.auth().confirmPasswordReset(resetCode, password);\n  };\n\n  const updateEmail = email => {\n    return firebase.auth().currentUser.updateEmail(email).then(() => {\n      // Update user in state (since onAuthStateChanged doesn't get called)\n      setUser(firebase.auth().currentUser);\n    });\n  };\n\n  const updatePassword = password => {\n    return firebase.auth().currentUser.updatePassword(password);\n  }; // Update auth user and persist to database (including any custom values in data)\n  // Forms can call this function instead of multiple auth/db update functions\n\n\n  const updateProfile = async data => {\n    const {\n      email,\n      name,\n      picture\n    } = data; // Update auth email\n\n    if (email) {\n      await firebase.auth().currentUser.updateEmail(email);\n    } // Update auth profile fields\n\n\n    if (name || picture) {\n      let fields = {};\n      if (name) fields.displayName = name;\n      if (picture) fields.photoURL = picture;\n      await firebase.auth().currentUser.updateProfile(fields);\n    } // Persist all data to the database\n\n\n    await updateUser(user.uid, data); // Update user in state\n\n    setUser(firebase.auth().currentUser);\n  };\n\n  useEffect(() => {\n    // Subscribe to user on mount\n    const unsubscribe = firebase.auth().onAuthStateChanged(user => {\n      if (user) {\n        setUser(user);\n      } else {\n        setUser(false);\n      }\n    }); // Unsubscribe on cleanup\n\n    return () => unsubscribe();\n  }, []);\n  return {\n    user: finalUser,\n    signup,\n    signin,\n    signinWithProvider,\n    signout,\n    sendPasswordResetEmail,\n    confirmPasswordReset,\n    updateEmail,\n    updatePassword,\n    updateProfile\n  };\n} // A Higher Order Component for requiring authentication\n\n\nexport const requireAuth = Component => {\n  return props => {\n    // Get authenticated user\n    const auth = useAuth();\n    useEffect(() => {\n      // Redirect if not signed in\n      if (auth.user === false) {\n        history.replace(\"/auth/signin\");\n      }\n    }, [auth]); // Show loading indicator\n    // We're either loading (user is null) or we're about to redirect (user is false)\n\n    if (!auth.user) {\n      return /*#__PURE__*/React.createElement(PageLoader, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 181,\n          columnNumber: 14\n        }\n      });\n    } // Render component now that we have user\n\n\n    return /*#__PURE__*/React.createElement(Component, Object.assign({}, props, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 185,\n        columnNumber: 12\n      }\n    }));\n  };\n}; // Format final user object and merge extra data from database\n\nfunction usePrepareUser(user) {\n  // Fetch extra data from database (if enabled and auth user has been fetched)\n  const userDbQuery = useUser(MERGE_DB_USER && user && user.uid); // Memoize so we only create a new object if user or userDbQuery changes\n\n  return useMemo(() => {\n    // Return if auth user is null (loading) or false (not authenticated)\n    if (!user) return user; // Data we want to include from auth user object\n\n    let finalUser = {\n      uid: user.uid,\n      email: user.email,\n      name: user.displayName,\n      picture: user.photoURL\n    }; // Include an array of user's auth providers, such as [\"password\", \"google\", etc]\n    // Components can read this to prompt user to re-auth with the correct provider\n\n    finalUser.providers = user.providerData.map(({\n      providerId\n    }) => {\n      return allProviders.find(p => p.id === providerId).name;\n    }); // If merging user data from database is enabled ...\n\n    if (MERGE_DB_USER) {\n      switch (userDbQuery.status) {\n        case \"loading\":\n          // Return null user so auth is considered loading until we have db data to merge\n          return null;\n\n        case \"error\":\n          // Log query error to console\n          console.error(userDbQuery.error);\n          return null;\n\n        case \"success\":\n          // If user data doesn't exist we assume this means user just signed up and the createUser\n          // function just hasn't completed. We return null to indicate a loading state.\n          if (userDbQuery.data === null) return null; // Merge user data from database into finalUser object\n\n          Object.assign(finalUser, userDbQuery.data);\n        // no default\n      }\n    }\n\n    return finalUser;\n  }, [user, userDbQuery]);\n}\n\nconst allProviders = [{\n  id: \"password\",\n  name: \"password\"\n}, {\n  id: \"google.com\",\n  name: \"google\",\n  providerMethod: firebase.auth.GoogleAuthProvider\n}, {\n  id: \"facebook.com\",\n  name: \"facebook\",\n  providerMethod: firebase.auth.FacebookAuthProvider,\n  parameters: {\n    // Tell fb to show popup size UI instead of full website\n    display: \"popup\"\n  }\n}, {\n  id: \"twitter.com\",\n  name: \"twitter\",\n  providerMethod: firebase.auth.TwitterAuthProvider\n}, {\n  id: \"github.com\",\n  name: \"github\",\n  providerMethod: firebase.auth.GithubAuthProvider\n}]; // Waits on Firebase user to be initialized before resolving promise\n// This is used to ensure auth is ready before any writing to the db can happen\n\nconst waitForFirebase = () => {\n  return new Promise(resolve => {\n    const unsubscribe = firebase.auth().onAuthStateChanged(user => {\n      if (user) {\n        resolve(user); // Resolve promise when we have a user\n\n        unsubscribe(); // Prevent from firing again\n      }\n    });\n  });\n};\n\nconst getFromQueryString = key => {\n  return queryString.parse(window.location.search)[key];\n};","map":{"version":3,"sources":["/Users/johnyoo/Desktop/OtterSpace/src/util/auth.js"],"names":["React","useState","useEffect","useMemo","useContext","createContext","queryString","firebase","useUser","createUser","updateUser","history","PageLoader","MERGE_DB_USER","authContext","ProvideAuth","children","auth","useProvideAuth","useAuth","user","setUser","finalUser","usePrepareUser","handleAuth","response","additionalUserInfo","waitForFirebase","isNewUser","uid","email","signup","password","createUserWithEmailAndPassword","then","signin","signInWithEmailAndPassword","signinWithProvider","name","providerData","allProviders","find","p","provider","providerMethod","parameters","setCustomParameters","signInWithPopup","signout","signOut","sendPasswordResetEmail","confirmPasswordReset","code","resetCode","getFromQueryString","updateEmail","currentUser","updatePassword","updateProfile","data","picture","fields","displayName","photoURL","unsubscribe","onAuthStateChanged","requireAuth","Component","props","replace","userDbQuery","providers","map","providerId","id","status","console","error","Object","assign","GoogleAuthProvider","FacebookAuthProvider","display","TwitterAuthProvider","GithubAuthProvider","Promise","resolve","key","parse","window","location","search"],"mappings":"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","sourcesContent":["import React, {\n  useState,\n  useEffect,\n  useMemo,\n  useContext,\n  createContext,\n} from \"react\";\nimport queryString from \"query-string\";\nimport firebase from \"./firebase\";\nimport { useUser, createUser, updateUser } from \"./db\";\nimport { history } from \"./router\";\nimport PageLoader from \"./../components/PageLoader\";\n\n// Whether to merge user data from database into auth.user\nconst MERGE_DB_USER = true;\n\nconst authContext = createContext();\n\n// Context Provider component that wraps your app and makes auth object\n// available to any child component that calls the useAuth() hook.\nexport function ProvideAuth({ children }) {\n  const auth = useProvideAuth();\n  return <authContext.Provider value={auth}>{children}</authContext.Provider>;\n}\n\n// Hook that enables any component to subscribe to auth state\nexport const useAuth = () => {\n  return useContext(authContext);\n};\n\n// Provider hook that creates auth object and handles state\nfunction useProvideAuth() {\n  // Store auth user object\n  const [user, setUser] = useState(null);\n\n  // Format final user object and merge extra data from database\n  const finalUser = usePrepareUser(user);\n\n  // Handle response from authentication functions\n  const handleAuth = async (response) => {\n    const { user, additionalUserInfo } = response;\n\n    // Ensure Firebase is actually ready before we continue\n    await waitForFirebase();\n\n    // Create the user in the database if they are new\n    if (additionalUserInfo.isNewUser) {\n      await createUser(user.uid, { email: user.email });\n    }\n\n    // Update user in state\n    setUser(user);\n    return user;\n  };\n\n  const signup = (email, password) => {\n    return firebase\n      .auth()\n      .createUserWithEmailAndPassword(email, password)\n      .then(handleAuth);\n  };\n\n  const signin = (email, password) => {\n    return firebase\n      .auth()\n      .signInWithEmailAndPassword(email, password)\n      .then(handleAuth);\n  };\n\n  const signinWithProvider = (name) => {\n    // Get provider data by name (\"password\", \"google\", etc)\n    const providerData = allProviders.find((p) => p.name === name);\n\n    const provider = new providerData.providerMethod();\n\n    if (providerData.parameters) {\n      provider.setCustomParameters(providerData.parameters);\n    }\n\n    return firebase.auth().signInWithPopup(provider).then(handleAuth);\n  };\n\n  const signout = () => {\n    return firebase.auth().signOut();\n  };\n\n  const sendPasswordResetEmail = (email) => {\n    return firebase.auth().sendPasswordResetEmail(email);\n  };\n\n  const confirmPasswordReset = (password, code) => {\n    // Get code from query string object\n    const resetCode = code || getFromQueryString(\"oobCode\");\n\n    return firebase.auth().confirmPasswordReset(resetCode, password);\n  };\n\n  const updateEmail = (email) => {\n    return firebase\n      .auth()\n      .currentUser.updateEmail(email)\n      .then(() => {\n        // Update user in state (since onAuthStateChanged doesn't get called)\n        setUser(firebase.auth().currentUser);\n      });\n  };\n\n  const updatePassword = (password) => {\n    return firebase.auth().currentUser.updatePassword(password);\n  };\n\n  // Update auth user and persist to database (including any custom values in data)\n  // Forms can call this function instead of multiple auth/db update functions\n  const updateProfile = async (data) => {\n    const { email, name, picture } = data;\n\n    // Update auth email\n    if (email) {\n      await firebase.auth().currentUser.updateEmail(email);\n    }\n\n    // Update auth profile fields\n    if (name || picture) {\n      let fields = {};\n      if (name) fields.displayName = name;\n      if (picture) fields.photoURL = picture;\n      await firebase.auth().currentUser.updateProfile(fields);\n    }\n\n    // Persist all data to the database\n    await updateUser(user.uid, data);\n\n    // Update user in state\n    setUser(firebase.auth().currentUser);\n  };\n\n  useEffect(() => {\n    // Subscribe to user on mount\n    const unsubscribe = firebase.auth().onAuthStateChanged((user) => {\n      if (user) {\n        setUser(user);\n      } else {\n        setUser(false);\n      }\n    });\n\n    // Unsubscribe on cleanup\n    return () => unsubscribe();\n  }, []);\n\n  return {\n    user: finalUser,\n    signup,\n    signin,\n    signinWithProvider,\n    signout,\n    sendPasswordResetEmail,\n    confirmPasswordReset,\n    updateEmail,\n    updatePassword,\n    updateProfile,\n  };\n}\n\n// A Higher Order Component for requiring authentication\nexport const requireAuth = (Component) => {\n  return (props) => {\n    // Get authenticated user\n    const auth = useAuth();\n\n    useEffect(() => {\n      // Redirect if not signed in\n      if (auth.user === false) {\n        history.replace(\"/auth/signin\");\n      }\n    }, [auth]);\n\n    // Show loading indicator\n    // We're either loading (user is null) or we're about to redirect (user is false)\n    if (!auth.user) {\n      return <PageLoader />;\n    }\n\n    // Render component now that we have user\n    return <Component {...props} />;\n  };\n};\n\n// Format final user object and merge extra data from database\nfunction usePrepareUser(user) {\n  // Fetch extra data from database (if enabled and auth user has been fetched)\n  const userDbQuery = useUser(MERGE_DB_USER && user && user.uid);\n\n  // Memoize so we only create a new object if user or userDbQuery changes\n  return useMemo(() => {\n    // Return if auth user is null (loading) or false (not authenticated)\n    if (!user) return user;\n\n    // Data we want to include from auth user object\n    let finalUser = {\n      uid: user.uid,\n      email: user.email,\n      name: user.displayName,\n      picture: user.photoURL,\n    };\n\n    // Include an array of user's auth providers, such as [\"password\", \"google\", etc]\n    // Components can read this to prompt user to re-auth with the correct provider\n    finalUser.providers = user.providerData.map(({ providerId }) => {\n      return allProviders.find((p) => p.id === providerId).name;\n    });\n\n    // If merging user data from database is enabled ...\n    if (MERGE_DB_USER) {\n      switch (userDbQuery.status) {\n        case \"loading\":\n          // Return null user so auth is considered loading until we have db data to merge\n          return null;\n        case \"error\":\n          // Log query error to console\n          console.error(userDbQuery.error);\n          return null;\n        case \"success\":\n          // If user data doesn't exist we assume this means user just signed up and the createUser\n          // function just hasn't completed. We return null to indicate a loading state.\n          if (userDbQuery.data === null) return null;\n\n          // Merge user data from database into finalUser object\n          Object.assign(finalUser, userDbQuery.data);\n\n        // no default\n      }\n    }\n\n    return finalUser;\n  }, [user, userDbQuery]);\n}\n\nconst allProviders = [\n  {\n    id: \"password\",\n    name: \"password\",\n  },\n  {\n    id: \"google.com\",\n    name: \"google\",\n    providerMethod: firebase.auth.GoogleAuthProvider,\n  },\n  {\n    id: \"facebook.com\",\n    name: \"facebook\",\n    providerMethod: firebase.auth.FacebookAuthProvider,\n    parameters: {\n      // Tell fb to show popup size UI instead of full website\n      display: \"popup\",\n    },\n  },\n  {\n    id: \"twitter.com\",\n    name: \"twitter\",\n    providerMethod: firebase.auth.TwitterAuthProvider,\n  },\n  {\n    id: \"github.com\",\n    name: \"github\",\n    providerMethod: firebase.auth.GithubAuthProvider,\n  },\n];\n\n// Waits on Firebase user to be initialized before resolving promise\n// This is used to ensure auth is ready before any writing to the db can happen\nconst waitForFirebase = () => {\n  return new Promise((resolve) => {\n    const unsubscribe = firebase.auth().onAuthStateChanged((user) => {\n      if (user) {\n        resolve(user); // Resolve promise when we have a user\n        unsubscribe(); // Prevent from firing again\n      }\n    });\n  });\n};\n\nconst getFromQueryString = (key) => {\n  return queryString.parse(window.location.search)[key];\n};\n"]},"metadata":{},"sourceType":"module"}