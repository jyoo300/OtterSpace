{"ast":null,"code":"const {\n  Transform\n} = require('readable-stream');\n\nfunction inherits(fn, sup) {\n  fn.super_ = sup;\n  fn.prototype = Object.create(sup.prototype, {\n    constructor: {\n      value: fn,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n} // create a new export function, used by both the main export and\n// the .ctor export, contains common logic for dealing with arguments\n\n\nfunction through2(construct) {\n  return (options, transform, flush) => {\n    if (typeof options === 'function') {\n      flush = transform;\n      transform = options;\n      options = {};\n    }\n\n    if (typeof transform !== 'function') {\n      // noop\n      transform = (chunk, enc, cb) => cb(null, chunk);\n    }\n\n    if (typeof flush !== 'function') {\n      flush = null;\n    }\n\n    return construct(options, transform, flush);\n  };\n} // main export, just make me a transform stream!\n\n\nconst make = through2((options, transform, flush) => {\n  const t2 = new Transform(options);\n  t2._transform = transform;\n\n  if (flush) {\n    t2._flush = flush;\n  }\n\n  return t2;\n}); // make me a reusable prototype that I can `new`, or implicitly `new`\n// with a constructor call\n\nconst ctor = through2((options, transform, flush) => {\n  function Through2(override) {\n    if (!(this instanceof Through2)) {\n      return new Through2(override);\n    }\n\n    this.options = Object.assign({}, options, override);\n    Transform.call(this, this.options);\n    this._transform = transform;\n\n    if (flush) {\n      this._flush = flush;\n    }\n  }\n\n  inherits(Through2, Transform);\n  return Through2;\n});\nconst obj = through2(function (options, transform, flush) {\n  const t2 = new Transform(Object.assign({\n    objectMode: true,\n    highWaterMark: 16\n  }, options));\n  t2._transform = transform;\n\n  if (flush) {\n    t2._flush = flush;\n  }\n\n  return t2;\n});\nmodule.exports = make;\nmodule.exports.ctor = ctor;\nmodule.exports.obj = obj;","map":{"version":3,"sources":["/Users/johnyoo/Desktop/OtterSpace/node_modules/@google-cloud/storage/node_modules/through2/through2.js"],"names":["Transform","require","inherits","fn","sup","super_","prototype","Object","create","constructor","value","enumerable","writable","configurable","through2","construct","options","transform","flush","chunk","enc","cb","make","t2","_transform","_flush","ctor","Through2","override","assign","call","obj","objectMode","highWaterMark","module","exports"],"mappings":"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","sourcesContent":["const { Transform } = require('readable-stream')\n\nfunction inherits (fn, sup) {\n  fn.super_ = sup\n  fn.prototype = Object.create(sup.prototype, {\n    constructor: { value: fn, enumerable: false, writable: true, configurable: true }\n  })\n}\n\n// create a new export function, used by both the main export and\n// the .ctor export, contains common logic for dealing with arguments\nfunction through2 (construct) {\n  return (options, transform, flush) => {\n    if (typeof options === 'function') {\n      flush = transform\n      transform = options\n      options = {}\n    }\n\n    if (typeof transform !== 'function') {\n      // noop\n      transform = (chunk, enc, cb) => cb(null, chunk)\n    }\n\n    if (typeof flush !== 'function') {\n      flush = null\n    }\n\n    return construct(options, transform, flush)\n  }\n}\n\n// main export, just make me a transform stream!\nconst make = through2((options, transform, flush) => {\n  const t2 = new Transform(options)\n\n  t2._transform = transform\n\n  if (flush) {\n    t2._flush = flush\n  }\n\n  return t2\n})\n\n// make me a reusable prototype that I can `new`, or implicitly `new`\n// with a constructor call\nconst ctor = through2((options, transform, flush) => {\n  function Through2 (override) {\n    if (!(this instanceof Through2)) {\n      return new Through2(override)\n    }\n\n    this.options = Object.assign({}, options, override)\n\n    Transform.call(this, this.options)\n\n    this._transform = transform\n    if (flush) {\n      this._flush = flush\n    }\n  }\n\n  inherits(Through2, Transform)\n\n  return Through2\n})\n\nconst obj = through2(function (options, transform, flush) {\n  const t2 = new Transform(Object.assign({ objectMode: true, highWaterMark: 16 }, options))\n\n  t2._transform = transform\n\n  if (flush) {\n    t2._flush = flush\n  }\n\n  return t2\n})\n\nmodule.exports = make\nmodule.exports.ctor = ctor\nmodule.exports.obj = obj\n"]},"metadata":{},"sourceType":"script"}